### 12 大型重构

#### 12.1 Tease Apart Inheritance（梳理并分解继承体系）

**做法**

- 首先识别和粗继承体系所承担的不同责任，然后建立一个二维表格。并以坐标抽标出不同的任务。我们将重复运用本重构，处理两个或两个以上的维度。
- 判断哪一项责任更重要些，并准备将它留在当前的继承体系中。准备将另一项责任移到另一个继承体系 中。
- 使用Extract Class（149）从当前的超类提炼出一个新类，用以表示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例。
- 对应于原继承体系中的每个子类，创建上述新类的一个子类，在原继承体系的子类中，将前一步骤所添加的实例变量初始化为新建子类的实例。
- 针对原继承体系的每个子类，使用Move Method（142）将其中的行为搬移到阈值对应的新建子类中。
- 当原继承体系中的某个字了不再有任何代码时，将其去除。
- 重复以上步骤，直到源继承体系中所有的子类都被处理过为止。观察新继承体系，看看是否有可能对让它实施其他的重构手法。

#### 12.2 Convert Procedural Design to Objects(将过程化设计转化为对象设计)

*将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中*

**做法**

- 针对每一个记录类型，将其转变为只含有访问函数的哑数据对象。
- 针对每一处过程化风格，将该处的代码提炼到一个独立类中。
- 针对每一段长长的程序，实施Extract Method(110)及其他相关重构将它分解。再以Move Method（142）将分解后的函数分别移到他所相关的哑数据类中。
- 重复上述步骤，知道原始类中的所有函数都被移除。如果原始类是一个完全过程化的类，将它拿掉将大快人心。

#### 12.3 Separate Domain From Presentation(将领域和表述、显示分开)

*将领域逻辑分离出来，为他们建立独立的领域类*

**做法**

- 为每个窗口建立一个领域类。
- 如果窗口内有一张表格，新建一个类来表示其中的行，再以窗口所对应之领域类中的一个集合来容纳所有的行领域。、
- 检查窗口中的数据，如果数据只被用于UI，就把他留着。如果数据被领域逻辑使用，而且不显示于窗口上。我们就以Move Field（146）将它搬移到领域类中。如果数据同时被UI和领域逻辑使用，就对他实施Duplicate Observed Data（189），使他同时存在于两处，并保持两处之间的同步。
- 检查展现类中的逻辑。试试Extract  Method（110）将展现逻辑从领域逻辑中分开。一旦隔离了领域逻辑，在运用Mover Method（142）将它移到领域类。
- 以上步骤完成后，你就拥有了两组彼此分离的类；展现类用以处理GUI，领域类包含所有业务逻辑。此时的领域类组织可能还不够严谨，更进一步的重构将解决这些问题。

#### 12.4 Extract Hierachy（提炼继承体系）

*建立继承体系，以一个子类表示一种特殊情况*

**做法**

- 鉴别出一种变化情况：

  > 如果这边变化可能在对象生命周期的不同阶段而又不同体现，就运用Extract CLass（149）将它提炼为一个独立的类。

- 针对这种变化情况，新建一个子类。并对原始类实施Replace Constructor with Factory Method(304)。在修改工厂函数，令他返回适当的子类实例。

- 将含有条件逻辑的函数。一次一个。逐一复制到子类，然后在明确情况下（对子类明确，对超类不明确），简化这些函数。

- 重复上述过程，将所有变化情况都分离出来，知道可以将超类声明为抽象类为止。

- 删除超类中哪些被所有子类覆写的函数本体，并将他们声明为抽象函数。

- 针对原始类的每一种变化情况，建立一个子类。

- 使用Replace Constructor with Factory Method(304),将原始类的构造函数转变为工厂函数，并令他针对每一种变化情况返回适当的子类实例。

- 针对带有条件逻辑的函数，实施Replace Conditional With Polymorphism(255)。如果并非整个函数的行为有所变化，而只是函数一部分有所变化，请先运用Extract Method(110)将变化部分和不变部分隔离开。



