#### 第6章 重新组织函数

Extract Method(110)最大的困难时处理局部变量，而临时变量则是其中一个主要的困难源头。

##### 6.1 Extract Method (提炼函数)

1. Extract Method(110)是我最常用的重构手法之一。当我看见一个过长的函数或者一段需要注释才能让人理解用途的代码，我就将这段代码放进一个独立的函数。
2. 如果每个函数的粒度都很小，那么函数被复用的机会就更大。
3. 函数命名长度不是问题，关键在与函数名称与函数本体之间的语义距离。

>做法：
>
>>创造一个新函数，根据函数的意图来对它命名（以它“做什么”来命名，而不是以它“怎么做”来命名）：即使你想要提炼的代码非常简单，例如只是一条消息或一个函数调用，只要新函数的名称能够以更好的方式招示代码意图，也应该提炼它。但如果想不出更有意义的名称，就别动。
>
>>将提炼出的代码从源函数复制到新建的目标函数中。
>
>>仔细渐渐提炼出的代码，看其中是否引用了“作用域限于源函数”的变量（包括局部变量和源函数参数）。
>
>> 检查是否有“仅用于被提炼代码段”的临时变量。如果有，在目标函数中将它们声明为临时变量。
>
>> 检查被提炼代码段，看看是否有任何局部变量的值被它改变。  如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询。并将结果复制给相关变量，如果很难这样做，或如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动的提炼出来。你可能需要先使用Split Temporary Variable(128),然后再尝试提炼。也可以使用Replace Temp With Query（120）将临时变量消灭掉。
>
>> 将被提炼代码段中需要读取的局部变量，当做参数传给目标函数。
>
>> 处理完所有局部变量之后，进行编译。
>
>> 在源函数中，将被提炼代码段替换为对目标函数的调用。
>
>> 编译，测试。

##### 6.2 Inline Method (内联函数)

动机

> > 有时候你遇到某些函数，其内部代码和函数名称同样清晰易读。重构了该函数后，其内容和名称同样清洗。你该直接使用其中的代码。
>
> > 可以将所要的函数的所有调用对象的函数内容都内联到函数对象中。



做法：

> > 检查函数，确定它不具多态性。如果子类继承了这函数，就不要将词函数内联，因为子类无法覆写一个根本不存在的函数。
>
> > 找出这个函数的所有被调用点。
>
> > 将这个函数的所有被调用点都替换为函数本体。
>
> > 编译、测试、
>
> > 删除该函数的定义。

##### 6.3 Inline Temp(内联临时变量)

动机：

> Inline Temp (119)多半是作为Replace Temp with Query（120）的一部分使用的，所以真正的动机出现在后者那儿。唯一单独使用Inline Temp（119）的情况是：你发现某个临时变量被赋予某个函数调用的返回值。一般说，这样的临时变量不会有任何危害，可以放心的把它留在那儿。但如果那个临时变量妨碍了其他的重构手法，例如Extract Method（110），你就应该将它内联化。

做法：

- 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用；
- 如果这个练市变量未被声明为final，那就将它声明为final，然后编译。>  这可以检查该临时变量是否真的只被赋值一次。
- 找到该临时变量的所有引用点，将他们替换为“为临时变量赋值”的表达式。
- 每次修改后,编译并测试。
- 修改完所有的引用点，删除该临时变量的声明和赋值语句。
- 编译、测试。

##### 6.4 Replace Temp with Query(以查询取代临时变量)

将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。伺候，新函数就可以被其他函数使用。

动机：

- 临时变量的问题在于：他们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以他们会驱使你写出更长的函数。
- Replace Temp with Query（120）往往是你运用Extract Method（110）之前必不可少的一个步骤。局部变量会使代码难以被提炼，所以你应该尽可能把他们替换为查询式。
- 这个重构手法较为简单的情况是：临时变量只被赋值一次，或者赋值给临时变量的表达式不受其他条件影响。

做法：

- 找出只被赋值一次的临时变量：如果某个临时变量被赋值超过一次，考虑使用Split Temporary Variable(128)将它分割成多个变量。

- 将该临时变量声明为final。

- 编译。

  > 这可确保该临时变量的确只被赋值一次。

- 将“对该临时变量赋值”之语句的等号右侧部分提炼到一个独立函数中

  > 首先将函数声明为private。日后你可能会发现有更多类需要使用它，那是放松对它的保护也很容易。

  > 确保提炼出来的函数无任何副作用，就是说该函数并不修改任何对象内容。如果有副作用，就对他进行Separate Query from Modifier（279）。

- 编译、测试。

- 在该临时变量身上实施Inline Temp （119）。

例子

重构之前：

```java
double getPrice(){
    int basePrice = _quantity * _itemPrice;
    double discountFactor;
    if (basePrice >1000) {
        discountFactor =0.95;
    }
    else{
    discountFactor= 0.98;    
    }
    return basePrice * discountFactor;
}
```

重构之后：

```java
private int basePrice(){
    return _quantity * _itemPrice;
}
private double discountFactor(){
    if(basePrice()>1000){
        return 0.95;
    }
    else{
        return 0.98;
    }
} 
double getPrice(){
    return basePrice()*discountFactor();
}
```



##### 6.5 Introduce Explaining Variable(引入解释性变量)

你有 一个复杂的表达式，将该复杂表达式（或其中一部分）的结果放进一个临时变量，一次变量名称来解释表达式用途。