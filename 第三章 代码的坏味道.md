#### 第三章 代码的坏味道

##### 3.1 Duplicated code (重复代码)

1. 同一个类的两个函数还有相同的表达式；
2. 两个互为兄弟的子类内含相同的表达式；

##### 3.2 Long Method (过长函数)

> 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。

如果函数内有大量参数和临时变量，会对函数提炼形成阻碍，如果尝试运用函数提取Extract Method（110），最终就会把许多参数和临时变量当做参数，传递给被提炼出来的新函数，导致可读性几乎没有提升。可以使用Replace Temp with query（120）来消除临时元素，Introduce Parameter Object（295）和Preserve Whole Object （288）将过长参数列表变简洁。如若还存在上述问题，就应考虑Replace Method with Method object（135）。

> 提炼代码技巧
>
> 1. 寻找注释：他们通常能指出代码用途和实现手法之间的语义距离；就算只有一行代码，如果需要以注释来说明，也值得提炼到独立函数去；
>
> 2. 条件表达式和循环常常也是提炼的信号。

###### 3.3 Large Class （过大的类）

1. 运用Extract Class（149）将几个变量一起提炼至新类内。提炼时应选择类内批次相关的变量，把他们放在一起。如果类内的数个变量有相同的前缀和字尾，就有机会把它们提炼到某个组件内。如果这个组件适合作为一个子类，使用Extract Subclass（330）比较简单。
2. 和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的元呕吐。最简单的解决方案是把多余的东西消弥于类内部。
3. 和“拥有太多实例变量”一样，一个雷如果拥有太多代码，往往也是和使用Extract Class（149）和Extract subClass（330）。使用技巧：先确定客户端如何使用他们，然后运用Extract interface(341)为每一种使用方式提炼出一个接口。

##### 3.4 Long Parameter List（过长参数列）

> 可使用对象技术改变这一情况；
>
> 注意：如果不希望造成“被调用对象”与“较大对象”之间的某种依赖关系，将数据从对象中拆解出来单独作为参数也很合情合理。如果参数列太长或变化太频繁，你就需要重新考虑依赖结构。

##### 3.5 Divergent Change(发散式变化)



